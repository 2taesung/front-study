# TDD

### **TDD란?**

**테스트 코드를 먼저 작성하는,**&#x20;

막연하게 접근하는게 아니라.&#x20;

이런게 있고 이런걸 넣으면 이렇게 돼!&#x20;

라는 구체적인 설계(인터페이스, 스펙)를 하고&#x20;

**구현에 들어가는 것을 말한다.**



### TDD Cycle

1. Red -> 실패하는 테스트 코드를 작성. 인터페이스와 스펙에 집중한다.
2. Green -> 재빨리 테스트를 통과시킨다. 올바른 방법이 아니어도 괜찮다
3. Refactor -> 리팩터링을 통해 코드를 올바르게 만든다. TDD에서 가장 중요한 부분이지만, 관과될 때가 많다.

\=> 캔트백(TDD창시자) 왈 2번을 빨리하기 위해서 죄악을 저질러도 괜찮다라고....

\=> 우리가 이걸 처음부터 완벽하게 하려고 하면 너무 힘들다.

\=> 그러나! 2번을 최대한 빠르게 해결한 후에 이것저것 바꿔보면서 해보는거야

\=> 그러다가 테스트가 깨진다? 그러면 다시 돌아가서 테스트를 맞추고..



\=> 프로그래밍, 소프트웨어는 눈에 보이지 않는것.

\=> 이것을 우리는 눈에 보이는 것으로 바꾸는 것이다.

\=> 그것을 증명하는 수단들 중 하나는 테스트.

\=> 또한 이것이 애매한 것들을 계속해서 해나가는 개발하는 과정에서도 좋은 영향을 끼칠 수 있는데

\=> 출발선과 목적지, 그리고 전체적인 틀을 주어 개발하는 애매한 것의 가이드라인과 범위를 제한하여 내가 개발을 하는데 여러가지가 예측이 가능하게 만들어준다.



롤제프리즈? (누구세요?)

TDD를 하는 목표는 clean code that works  '제대로 돌아가는 클린코드'

\=> 가장 첫번째 조건으로 일단제대로 돌아가야한다.

\=> 그 후에 예술의 혼을 담아서 깎아나가야 함.(리펙토링)



마틴 파울러의 리팩토링 책을 보면 동작은 바뀌지 않는 상태에 내부에 구현되는 코드는 바뀌는것.



> **작은 단계를 찾고, 코드에서 피드백을 얻는 게 (어렵고) 중요하다. 2번이 어렵다면 1번으로 돌아가서 더 작고 쉬운 문제를 정의하고, 3번을 위해 의도를 드러내고 중복을 찾아 제거하는 연습을 해야 한다. 이 둘이 익숙하지 않으면 TDD를 하는 게 거의 불가능하고, 사실 이 둘이 어려우면 일반적인 개발 또는 클린 코드를 작성하는 것 또한 매우 힘들다.**



**작은 단계를 찾고, 코드에서 피드백을 얻는 게 (어렵고) 중요하다. 2번이 어렵다면 1번으로 돌아가서 더 작고 쉬운 문제를 정의**



\=>  이 작업을 반복해서 해서 코드를 최선의 코드로 만들어야함.

\=> 이 작업을 1주일동안 한다면 반복을 할 수 없겠지.

\=> 고로 1. 2. 번을 1분 이하 최소한 10분 이하로 만들어놓아야 함.

\=> 만약 1,2번을 짧게 잡고 하려고 하는데 안돼.. 그러면 설계를 잘못한거다&#x20;

\=> 1번을 더 작게 쪼게야 함. (기준이 생기는 것, 작성할때 10분 이내의 단위의 로직이여야 함)



**3번을 위해 의도를 드러내고 중복을 찾아 제거하는 연습을 해야 한다.**

\=> 이 과정에서 함수명 등의 목적을 가진 의도를 재확인해 의도를 드러내고

\=>  변수를 통해 중복을 제거한다.



예를들어,

<figure><img src="../.gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

다음과 같이 막무가내로 짜놓고.

그 다음에 중복되는 내용들을 반복문, 함수, 변수 등등을 활용해 바꿔나간다.

\=> 꼭 알고리즘 테스트 접근하는거 같기도 ...

\=> 하나하나 해보고 그다음에 규칙을 찾아내 자료구조 등등을 적용하니까.



\=> 코딩을 실제로 하는 입장에서 한번 생각해보면 나는 항상 맨처음부터 떠오르는 로직들을 바로 적어내기 시작했다.

\=> 이렇게 되면 쉬운거야 뭐 바로내 손에서 해결되지만 복잡한 로직의 경우에는 로직이 추가되고 디버깅들을 하면서 덕지덕지 아무런 기준도 없이 코드가 망가지기 시작함.

\=> 또한, 이미 작성한 코드를 다시 돌아볼 기회도 잃음.

\=> 힘들게 돌아가게 만들었으니.













